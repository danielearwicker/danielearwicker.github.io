<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> A new kind of managed lvalue pointer | Daniel Earwicker </title> <meta name="author" content="Daniel Earwicker"> <meta name="description" content="You are almost certainly lost on the Internet. "> <meta name="keywords" content="coding, physics"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.png?754e6b58bcf99910aed4f8d8638bd47f"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://danielearwicker.github.io/blog/2014/A-new-kind-of-managed-lvalue-pointer/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Daniel</span> Earwicker </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">A new kind of managed lvalue pointer</h1> <p class="post-meta"> Created on April 27, 2014 </p> <p class="post-tags"> <a href="/blog/2014"> <i class="fa-solid fa-calendar fa-sm"></i> 2014 </a>   ·   <a href="/blog/tag/roslyn"> <i class="fa-solid fa-hashtag fa-sm"></i> roslyn</a>   <a href="/blog/tag/c"> <i class="fa-solid fa-hashtag fa-sm"></i> c#</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>It’s already the evening and I haven’t yet added anything to the C# compiler today, so here goes!</p> <p>Properties have special support in C#, but they are not “first class”. You can’t get a reference to a property and pass it around as a value. Methods are much better served in this regard: delegates are a way to treat a method as a value. But they are just objects with an <code class="language-plaintext highlighter-rouge">Invoke</code> method.</p> <p>So all we need is an interface with a <code class="language-plaintext highlighter-rouge">Value</code> property. Objects supporting that interface can represent a single property that can be passed around like any other value:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">interface</span> <span class="nc">IProperty</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
<span class="p">{</span>
    <span class="n">T</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>This is closely analogous to an old-fashioned pointer in C and C++, <a href="http://smellegantcode.wordpress.com/2008/05/06/pointers-to-value-types-in-c/" rel="external nofollow noopener" target="_blank">as I mused aloud all those years ago</a>. Let’s turn that whole idea into a strangely alluring language feature, which I’ll call “property references”, and then occasionally forget that terminology and call them pointers instead.</p> <p>Firstly, syntax. We could use actual pointer syntax, but <a href="../Pointers-IEnumerable">I already used some of that in yesterday’s feature</a>. Dagnabbit! Fortunately <a href="http://en.wikipedia.org/wiki/C%2B%2B/CX" rel="external nofollow noopener" target="_blank">C++/CX</a> has already paved the way: it has the concept of a reference to a fancy object that must be explicitly dereferenced. The syntax is like this:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">MyClass</span> <span class="p">^</span><span class="n">r</span> <span class="p">=</span> <span class="p">%</span><span class="n">x</span><span class="p">;</span>

<span class="p">(*</span><span class="n">r</span><span class="p">).</span><span class="nf">Foo</span><span class="p">();</span>
</code></pre></div></div> <p>If this looks weird, try replacing <code class="language-plaintext highlighter-rouge">^</code> with <code class="language-plaintext highlighter-rouge">*</code> and <code class="language-plaintext highlighter-rouge">%</code> with <code>&amp;</code>. It’s then exactly like C/C++. <code class="language-plaintext highlighter-rouge">^</code> is a postfix modifier on a type declaration that means “Will store a pointer to one of those”, and <code class="language-plaintext highlighter-rouge">%</code> is a unary prefix operator that means “Give me a pointer to whatever comes next”. And for the sake of uniformity in common code, C++/CX always uses <code class="language-plaintext highlighter-rouge">*</code> to dereference.</p> <p>Before getting into the nitty-gritty of changing the compiler, let’s survey the glorious sunny uplands we wish to invade. We should be able to do this in C#:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">x</span> <span class="p">=</span> <span class="m">5</span><span class="p">;</span>
<span class="kt">var</span> <span class="n">px</span> <span class="p">=</span> <span class="p">%</span><span class="n">x</span><span class="p">;</span> <span class="c1">// Take a "pointer" to x</span>

<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(*</span><span class="n">px</span><span class="p">);</span> <span class="c1">// Prints 5</span>

<span class="p">*</span><span class="n">px</span> <span class="p">=</span> <span class="m">6</span><span class="p">;</span> <span class="c1">// Can assign "through" a pointer</span>
<span class="p">(*</span><span class="n">px</span><span class="p">)++;</span> <span class="c1">// Or increment</span>

<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="c1">// Prints 7 - we modified x via px</span>
</code></pre></div></div> <p>Unlike old-school pointers, we can - of course - quite safely return one of these things from a method, <em>referring to a local variable</em>:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int</span><span class="p">^</span> <span class="nf">GetCounter</span><span class="p">(</span><span class="kt">int</span> <span class="k">init</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">counter</span> <span class="p">=</span> <span class="k">init</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">%</span><span class="n">counter</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// elsewhere...</span>
<span class="kt">var</span> <span class="n">c</span> <span class="p">=</span> <span class="nf">GetCounter</span><span class="p">(</span><span class="m">100</span><span class="p">);</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(*</span><span class="n">c</span><span class="p">);</span> <span class="c1">// Prints 100</span>

<span class="p">(*</span><span class="n">c</span><span class="p">)++;</span>
<span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(*</span><span class="n">c</span><span class="p">);</span> <span class="c1">// Prints 101</span>
</code></pre></div></div> <p>The trick is that each bit of new syntax expands very simply into some standard C#. All the heavy lifting is done by the compiler’s existing support for lambdas:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">x</span> <span class="p">=</span> <span class="m">5</span><span class="p">;</span>
<span class="n">System</span><span class="p">.</span><span class="n">IProperty</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">&gt;</span> <span class="n">px</span> <span class="p">=</span> <span class="n">System</span><span class="p">.</span><span class="n">Property</span><span class="p">.</span><span class="nf">Bind</span><span class="p">(</span><span class="n">v</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">=</span> <span class="n">v</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// int *p = %x;</span>
<span class="kt">var</span> <span class="n">y</span> <span class="p">=</span> <span class="n">px</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span> <span class="c1">// var y = *x;</span>
</code></pre></div></div> <p>But of course, those helper types are not part of the standard <code class="language-plaintext highlighter-rouge">System</code> namespace. We need to add them:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="nn">System</span>
<span class="p">{</span>
    <span class="k">public</span> <span class="k">interface</span> <span class="nc">IProperty</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="n">T</span> <span class="n">Value</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">static</span> <span class="k">class</span> <span class="nc">Property</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="k">class</span> <span class="nc">PtrImpl</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">IProperty</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
        <span class="p">{</span>
            <span class="n">Action</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">_set</span><span class="p">;</span>
            <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">_get</span><span class="p">;</span>

            <span class="k">public</span> <span class="nf">PtrImpl</span><span class="p">(</span><span class="n">Action</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="k">set</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="k">get</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">_set</span> <span class="p">=</span> <span class="k">set</span><span class="p">;</span>
                <span class="n">_get</span> <span class="p">=</span> <span class="k">get</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">public</span> <span class="n">T</span> <span class="n">Value</span>
            <span class="p">{</span>
                <span class="k">get</span> <span class="p">{</span> <span class="k">return</span> <span class="nf">_get</span><span class="p">();</span> <span class="p">}</span>
                <span class="k">set</span> <span class="p">{</span> <span class="nf">_set</span><span class="p">(</span><span class="k">value</span><span class="p">);</span> <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">static</span> <span class="n">IProperty</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Bind</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Action</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="k">set</span><span class="p">,</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="k">get</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">PtrImpl</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="k">set</span><span class="p">,</span> <span class="k">get</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>These don’t need to be in <code class="language-plaintext highlighter-rouge">mscorlib.dll</code> (some of the later C# features rely on types in <code class="language-plaintext highlighter-rouge">System.Core.dll</code>). So we can just create a new <code class="language-plaintext highlighter-rouge">System.Extras.dll</code> assembly and stick them in there.</p> <p>So, one thing that makes this a whole ‘nother level of crazy compared to my first two forays in to compiler features is that here we are adding new syntax. Fortunately Roslyn makes this quite easy. There’s a file called <code class="language-plaintext highlighter-rouge">Syntax.xml</code> from which the project generates classes for all the nodes that can appear in a syntax tree. We can (as usual) follow the example of what we find in there.</p> <p>All the unary prefix operators are in here, so they share a single class that can be distinguished by the <code class="language-plaintext highlighter-rouge">Kind</code> property:</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;Node</span> <span class="na">Name=</span><span class="s">"PrefixUnaryExpressionSyntax"</span> <span class="na">Base=</span><span class="s">"ExpressionSyntax"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;Kind</span> <span class="na">Name=</span><span class="s">"UnaryPlusExpression"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;Kind</span> <span class="na">Name=</span><span class="s">"UnaryMinusExpression"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;Kind</span> <span class="na">Name=</span><span class="s">"BitwiseNotExpression"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;Kind</span> <span class="na">Name=</span><span class="s">"LogicalNotExpression"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;Kind</span> <span class="na">Name=</span><span class="s">"PreIncrementExpression"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;Kind</span> <span class="na">Name=</span><span class="s">"PreDecrementExpression"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;Kind</span> <span class="na">Name=</span><span class="s">"AddressOfExpression"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;Kind</span> <span class="na">Name=</span><span class="s">"PointerIndirectionExpression"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;Kind</span> <span class="na">Name=</span><span class="s">"AwaitExpression"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;Kind</span> <span class="na">Name=</span><span class="s">"PropertyReferenceExpression"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;Field</span> <span class="na">Name=</span><span class="s">"OperatorToken"</span> <span class="na">Type=</span><span class="s">"SyntaxToken"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Kind</span> <span class="na">Name=</span><span class="s">"PlusToken"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Kind</span> <span class="na">Name=</span><span class="s">"MinusToken"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Kind</span> <span class="na">Name=</span><span class="s">"TildeToken"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Kind</span> <span class="na">Name=</span><span class="s">"ExclamationToken"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Kind</span> <span class="na">Name=</span><span class="s">"PlusPlusToken"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Kind</span> <span class="na">Name=</span><span class="s">"MinusMinusToken"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Kind</span> <span class="na">Name=</span><span class="s">"AmpersandToken"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Kind</span> <span class="na">Name=</span><span class="s">"AsteriskToken"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Kind</span> <span class="na">Name=</span><span class="s">"AwaitKeyword"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;Kind</span> <span class="na">Name=</span><span class="s">"PercentToken"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;PropertyComment&gt;</span>
      <span class="nt">&lt;summary&gt;</span>SyntaxToken representing the kind of the operator of the prefix unary expression.<span class="nt">&lt;/summary&gt;</span>
    <span class="nt">&lt;/PropertyComment&gt;</span>
  <span class="nt">&lt;/Field&gt;</span>
  <span class="nt">&lt;Field</span> <span class="na">Name=</span><span class="s">"Operand"</span> <span class="na">Type=</span><span class="s">"ExpressionSyntax"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;PropertyComment&gt;</span>
      <span class="nt">&lt;summary&gt;</span>ExpressionSyntax representing the operand of the prefix unary expression.<span class="nt">&lt;/summary&gt;</span>
    <span class="nt">&lt;/PropertyComment&gt;</span>
  <span class="nt">&lt;/Field&gt;</span>
  <span class="nt">&lt;TypeComment&gt;</span>
    <span class="nt">&lt;summary&gt;</span>Class which represents the syntax node for prefix unary expression.<span class="nt">&lt;/summary&gt;</span>
  <span class="nt">&lt;/TypeComment&gt;</span>
  <span class="nt">&lt;FactoryComment&gt;</span>
    <span class="nt">&lt;summary&gt;</span>Creates an PrefixUnaryExpressionSyntax node.<span class="nt">&lt;/summary&gt;</span>
  <span class="nt">&lt;/FactoryComment&gt;</span>
<span class="nt">&lt;/Node&gt;</span>
</code></pre></div></div> <p>I’ve added the <code class="language-plaintext highlighter-rouge">PropertyReferenceExpression</code> and the <code class="language-plaintext highlighter-rouge">PercentToken</code>. For the type modifier <code class="language-plaintext highlighter-rouge">^</code> I have to cook up a whole new node type:</p> <div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;Node</span> <span class="na">Name=</span><span class="s">"PropertyReferenceTypeSyntax"</span> <span class="na">Base=</span><span class="s">"TypeSyntax"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;Kind</span> <span class="na">Name=</span><span class="s">"PropertyReferenceType"</span><span class="nt">/&gt;</span>
  <span class="nt">&lt;Field</span> <span class="na">Name=</span><span class="s">"ElementType"</span> <span class="na">Type=</span><span class="s">"TypeSyntax"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;PropertyComment&gt;</span>
      <span class="nt">&lt;summary&gt;</span>TypeSyntax node that represents the element type of the property reference.<span class="nt">&lt;/summary&gt;</span>
    <span class="nt">&lt;/PropertyComment&gt;</span>
  <span class="nt">&lt;/Field&gt;</span>
  <span class="nt">&lt;Field</span> <span class="na">Name=</span><span class="s">"CaretToken"</span> <span class="na">Type=</span><span class="s">"SyntaxToken"</span><span class="nt">&gt;</span>
    <span class="nt">&lt;Kind</span> <span class="na">Name=</span><span class="s">"CaretToken"</span><span class="nt">/&gt;</span>
    <span class="nt">&lt;PropertyComment&gt;</span>
      <span class="nt">&lt;summary&gt;</span>SyntaxToken representing the caret symbol.<span class="nt">&lt;/summary&gt;</span>
    <span class="nt">&lt;/PropertyComment&gt;</span>
  <span class="nt">&lt;/Field&gt;</span>
  <span class="nt">&lt;TypeComment&gt;</span>
    <span class="nt">&lt;summary&gt;</span>Class which represents the syntax node for property reference type.<span class="nt">&lt;/summary&gt;</span>
  <span class="nt">&lt;/TypeComment&gt;</span>
  <span class="nt">&lt;FactoryComment&gt;</span>
    <span class="nt">&lt;summary&gt;</span>Creates a PropertyReferenceTypeSyntax node.<span class="nt">&lt;/summary&gt;</span>
  <span class="nt">&lt;/FactoryComment&gt;</span>
<span class="nt">&lt;/Node&gt;</span>
</code></pre></div></div> <p>Now, if we try to build the compiler we’ll get errors about missing names in the <code class="language-plaintext highlighter-rouge">enum SyntaxKind</code>, so we need to add them:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">enum</span> <span class="n">SyntaxKind</span> <span class="p">:</span> <span class="kt">ushort</span>
<span class="p">{</span>
    <span class="p">...</span>

    <span class="n">PropertyReferenceType</span><span class="p">,</span>
    <span class="n">PropertyReferenceExpression</span>
<span class="p">}</span>
</code></pre></div></div> <p>In <code class="language-plaintext highlighter-rouge">SyntaxKindFacts.cs</code> there’s a workaday <code class="language-plaintext highlighter-rouge">switch</code> statement that we need to modify so it takes care of mapping <code class="language-plaintext highlighter-rouge">%</code> tokens to our new unary operator:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="n">SyntaxKind</span> <span class="nf">GetPrefixUnaryExpression</span><span class="p">(</span><span class="n">SyntaxKind</span> <span class="n">token</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">token</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">PlusToken</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">UnaryPlusExpression</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">MinusToken</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">UnaryMinusExpression</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">TildeToken</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">BitwiseNotExpression</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">ExclamationToken</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">LogicalNotExpression</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">PlusPlusToken</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">PreIncrementExpression</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">MinusMinusToken</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">PreDecrementExpression</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">AmpersandToken</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">AddressOfExpression</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">AsteriskToken</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">PointerIndirectionExpression</span><span class="p">;</span>

        <span class="c1">// The new part:</span>
        <span class="k">case</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">PercentToken</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">PropertyReferenceExpression</span><span class="p">;</span>

        <span class="k">default</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">None</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>And there’s a another that defines the precedence of operators, which is how the compiler decides what to do when you don’t fully parenthesise your expressions. I figure that the new <code class="language-plaintext highlighter-rouge">%</code> operator should copy the existing <code class="language-plaintext highlighter-rouge">&amp;amp</code> operator:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">static</span> <span class="kt">uint</span> <span class="nf">GetPrecedence</span><span class="p">(</span><span class="n">SyntaxKind</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">op</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">...</span>

        <span class="k">case</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">AddressOfExpression</span><span class="p">:</span>
        <span class="k">case</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">PropertyReferenceExpression</span><span class="p">:</span> <span class="c1">// the new part</span>
            <span class="k">return</span> <span class="m">16</span><span class="p">;</span>
        <span class="k">default</span><span class="p">:</span>
            <span class="k">return</span> <span class="m">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>For the all-new <code class="language-plaintext highlighter-rouge">^</code> operator we have to throw some code in to deal with it. Like I said yesterday, Roslyn’s structure seems surprisingly procedural. It’s not using functional parser combinators or anything “cool” and/or “academic”. It’s just a bunch of methods that examine the current token, do switch statements, etc. On the plus side, it is very easy to learn how it works by stepping through it in the debugger. That’s the saving grace of procedural code: ease of hacking.</p> <p>I hooked into the same place that handles pointer syntax, as (again) its closely analogous.</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="n">TypeSyntax</span> <span class="nf">ParsePointerTypeMods</span><span class="p">(</span><span class="n">TypeSyntax</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Check for pointer types</span>
    <span class="k">while</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">CurrentToken</span><span class="p">.</span><span class="n">Kind</span> <span class="p">==</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">AsteriskToken</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">type</span> <span class="p">=</span> <span class="n">syntaxFactory</span><span class="p">.</span><span class="nf">PointerType</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nf">EatToken</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="c1">// Check for property reference types (new)</span>
    <span class="k">while</span> <span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="n">CurrentToken</span><span class="p">.</span><span class="n">Kind</span> <span class="p">==</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">CaretToken</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">type</span> <span class="p">=</span> <span class="n">syntaxFactory</span><span class="p">.</span><span class="nf">PropertyReferenceType</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nf">EatToken</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>Note: we don’t have to write that <code class="language-plaintext highlighter-rouge">syntaxFactory.PropertyReferenceType</code> method. It’s one of the pieces that are auto-generated from what we added to <code class="language-plaintext highlighter-rouge">Syntax.xml</code>.</p> <p>Now, we have the syntax. All we need now is to sort out the binding phase, which figures out whether the syntax actually makes sense (that when it refers to a variable called <code class="language-plaintext highlighter-rouge">x</code>, there actually is one called <code class="language-plaintext highlighter-rouge">x</code>, and every expression has a type, etc.)</p> <p>And it is here that I am overcome with one of those attacks of laziness that are the hallmark of the truly great programmer, hem-hem. Faced with a pattern like this:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">System</span><span class="p">.</span><span class="n">Property</span><span class="p">.</span><span class="nf">Bind</span><span class="p">(</span><span class="n">v</span> <span class="p">=&gt;</span> <span class="n">o</span> <span class="p">=</span> <span class="n">v</span><span class="p">,</span> <span class="p">()</span> <span class="p">=&gt;</span> <span class="n">o</span><span class="p">)</span>
</code></pre></div></div> <p>We don’t want to have to write screeds of code that builds the <code class="language-plaintext highlighter-rouge">BoundExpression</code> that make up that pattern (believe me: I got about half-way through the first lambda before realising I would be retired before finishing the whole thing). In any case, the compiler can already do it - that’s its job. Ideally we could use the existing parser to get a kind of “syntax template”, in which we can replace certain identifiers with chunks of other syntax, and then ask the existing binder to bind it. Then we’d have to do almost <em>no thinking at all</em>! Bliss.</p> <p>So for example:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">SyntaxTemplate</span> <span class="n">_propertyReferenceTemplate</span>
    <span class="p">=</span> <span class="k">new</span> <span class="nf">SyntaxTemplate</span><span class="p">(</span><span class="s">"System.Property.Bind(__v_pr__ =&gt; o = __v_pr__, () =&gt; o)"</span><span class="p">);</span>

<span class="k">private</span> <span class="n">BoundExpression</span> <span class="nf">BindPropertyReferenceExpression</span><span class="p">(</span><span class="n">PrefixUnaryExpressionSyntax</span> <span class="n">node</span><span class="p">,</span> <span class="n">DiagnosticBag</span> <span class="n">diagnostics</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="nf">RedirectDiagnostics</span><span class="p">(</span><span class="n">diagnostics</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">redirected</span> <span class="p">=&gt;</span>
        <span class="nf">BindExpression</span><span class="p">(</span><span class="n">_propertyReferenceTemplate</span><span class="p">.</span><span class="nf">Replace</span><span class="p">(</span><span class="s">"o"</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">Operand</span><span class="p">).</span><span class="n">Syntax</span><span class="p">,</span> <span class="n">redirected</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div> <p>We’ll come back to that <code class="language-plaintext highlighter-rouge">RedirectDiagnostics</code> part later. The key point is that I’m creating an instance of my new class <code class="language-plaintext highlighter-rouge">SyntaxTemplate</code> as a <code class="language-plaintext highlighter-rouge">static</code>, so it is reused for the lifetime of the compiler. It’s immutable, hence thread-safe. Then every time I need to bind something like <code class="language-plaintext highlighter-rouge">%foo</code>, I can just replace the <code class="language-plaintext highlighter-rouge">o</code> in the template with <code class="language-plaintext highlighter-rouge">foo</code> (which is in <code class="language-plaintext highlighter-rouge">node.Operand</code>). <code class="language-plaintext highlighter-rouge">Replace</code> returns a new <code class="language-plaintext highlighter-rouge">SyntaxTemplate</code> rather than modifying the original (that’s what immutability is all about).</p> <p>Again, binding is a recursive, procedural system. There’s a big switch statement that calls out to methods that bind various things, so we need to hook our new method <code class="language-plaintext highlighter-rouge">BindPropertyReferenceExpression</code> into that:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="n">BoundExpression</span> <span class="nf">BindExpressionInternal</span><span class="p">(</span><span class="n">ExpressionSyntax</span> <span class="n">node</span><span class="p">,</span> <span class="n">DiagnosticBag</span> <span class="n">diagnostics</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">invoked</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">indexed</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">IsEarlyAttributeBinder</span> <span class="p">&amp;&amp;</span> <span class="p">!</span><span class="n">EarlyWellKnownAttributeBinder</span><span class="p">.</span><span class="nf">CanBeValidAttributeArgument</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">this</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="nf">BadExpression</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">LookupResultKind</span><span class="p">.</span><span class="n">NotAValue</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">Debug</span><span class="p">.</span><span class="nf">Assert</span><span class="p">(</span><span class="n">node</span> <span class="p">!=</span> <span class="k">null</span><span class="p">);</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Kind</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">...</span>

        <span class="c1">// New part</span>
        <span class="k">case</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">PropertyReferenceExpression</span><span class="p">:</span>
            <span class="k">return</span> <span class="nf">BindPropertyReferenceExpression</span><span class="p">((</span><span class="n">PrefixUnaryExpressionSyntax</span><span class="p">)</span><span class="n">node</span><span class="p">,</span> <span class="n">diagnostics</span><span class="p">);</span>
</code></pre></div></div> <p>See how there’s a <code class="language-plaintext highlighter-rouge">switch</code> statement on an <code class="language-plaintext highlighter-rouge">enum</code>, then a cast - all the kinds of thing that beginners are told not to do when they learn C#, because supposedly virtual method dispatch on a single object solves all problems. (<a href="http://stackoverflow.com/questions/1406860/how-can-i-replace-instanceof-in-this-case" rel="external nofollow noopener" target="_blank">Oh wait, no it doesn’t</a>.) But still, it wouldn’t make sense to have a built-in type switch in languages like C#, Java or C++ (<a href="http://stackoverflow.com/a/1166083/27423" rel="external nofollow noopener" target="_blank">except apparently in one situation</a>).</p> <p>Anyway, <code class="language-plaintext highlighter-rouge">BindExpression</code> calls <code class="language-plaintext highlighter-rouge">BindExpressionInternal</code>, which calls our new <code class="language-plaintext highlighter-rouge">BindPropertyReferenceExpression</code> method, which expands our template and passes it to <code class="language-plaintext highlighter-rouge">BindExpression</code>… we’re going in circles! But it’s okay. The reason this doesn’t asplode the stack is because our template doesn’t include further references to <code class="language-plaintext highlighter-rouge">%</code>.</p> <p>Now, about that <code class="language-plaintext highlighter-rouge">RedirectDiagnostics</code> wrinkle. The binding process has a <code class="language-plaintext highlighter-rouge">DiagnosticBag</code> object that gets passed around. Any errors found are thrown in the bag. Each error has a <code class="language-plaintext highlighter-rouge">Location</code> object, identifying the place in the user’s source code where the error was spotted, so the locations were discovered at the parsing stage. The problem we have is that we parse our template code separately, so the locations bear no relation to the user’s source code. This means that the IDE’s text editor cannot put red squiggles in the right place.</p> <p>To fix this, I literally fix the diagnostics:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="n">T</span> <span class="n">RedirectDiagnostics</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">DiagnosticBag</span> <span class="n">diagnostics</span><span class="p">,</span>
             <span class="n">CSharpSyntaxNode</span> <span class="n">nodeWithLocation</span><span class="p">,</span>
             <span class="n">Func</span><span class="p">&lt;</span><span class="n">DiagnosticBag</span><span class="p">,</span> <span class="n">T</span><span class="p">&gt;</span> <span class="n">generate</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">var</span> <span class="n">captured</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">DiagnosticBag</span><span class="p">();</span>
    <span class="kt">var</span> <span class="n">result</span> <span class="p">=</span> <span class="nf">generate</span><span class="p">(</span><span class="n">captured</span><span class="p">);</span>

    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">diag</span> <span class="k">in</span> <span class="n">captured</span><span class="p">.</span><span class="nf">AsEnumerable</span><span class="p">().</span><span class="n">OfType</span><span class="p">&lt;</span><span class="n">DiagnosticWithInfo</span><span class="p">&gt;())</span>
        <span class="n">diagnostics</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="k">new</span> <span class="nf">CSDiagnostic</span><span class="p">(</span><span class="n">diag</span><span class="p">.</span><span class="n">Info</span><span class="p">,</span> <span class="n">nodeWithLocation</span><span class="p">.</span><span class="n">Location</span><span class="p">));</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>The <code class="language-plaintext highlighter-rouge">generate</code> function does the binding, but to a “fake” temporary <code class="language-plaintext highlighter-rouge">DiagnosticBag</code>, which we then copy into the real one but replacing all the <code class="language-plaintext highlighter-rouge">Location</code> objects with a single good location. This isn’t ideal. Recall that some of the syntax tree was inserted from the user’s source and so had perfectly good locations. I need to figure out a way of detecting whether a location is junk or not. But it sort of works.</p> <p>So, we have binding for <code class="language-plaintext highlighter-rouge">%</code>. For <code class="language-plaintext highlighter-rouge">*</code> we have to enhance the existing code, branching based on whether operand is a pointer:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">SyntaxTemplate</span> <span class="n">_pointerIndirectionTemplate</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SyntaxTemplate</span><span class="p">(</span><span class="s">"p.Value"</span><span class="p">);</span>

<span class="c1">// Based on ExpressionBinder::bindPtrIndirection.</span>
<span class="k">private</span> <span class="n">BoundExpression</span> <span class="nf">BindPointerIndirectionExpression</span><span class="p">(</span><span class="n">PrefixUnaryExpressionSyntax</span> <span class="n">node</span><span class="p">,</span> <span class="n">DiagnosticBag</span> <span class="n">diagnostics</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">BoundExpression</span> <span class="n">operand</span> <span class="p">=</span> <span class="nf">BindValue</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Operand</span><span class="p">,</span> <span class="n">diagnostics</span><span class="p">,</span> <span class="nf">GetUnaryAssignmentKind</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Kind</span><span class="p">));</span>

    <span class="c1">// Try using the template on anything that isn't a pointer</span>
    <span class="k">if</span> <span class="p">(!</span><span class="n">operand</span><span class="p">.</span><span class="n">Type</span><span class="p">.</span><span class="nf">IsPointerType</span><span class="p">())</span>
        <span class="k">return</span> <span class="nf">RedirectDiagnostics</span><span class="p">(</span><span class="n">diagnostics</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">redirected</span> <span class="p">=&gt;</span>
            <span class="nf">BindExpression</span><span class="p">(</span><span class="n">_pointerIndirectionTemplate</span><span class="p">.</span><span class="nf">Replace</span><span class="p">(</span><span class="s">"p"</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">Operand</span><span class="p">).</span><span class="n">Syntax</span><span class="p">,</span> <span class="n">redirected</span><span class="p">));</span>

    <span class="n">TypeSymbol</span> <span class="n">pointedAtType</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">hasErrors</span><span class="p">;</span>
    <span class="nf">BindPointerIndirectionExpressionInternal</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="n">diagnostics</span><span class="p">,</span> <span class="k">out</span> <span class="n">pointedAtType</span><span class="p">,</span> <span class="k">out</span> <span class="n">hasErrors</span><span class="p">);</span>

    <span class="k">return</span> <span class="k">new</span> <span class="nf">BoundPointerIndirectionOperator</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">operand</span><span class="p">,</span> <span class="n">pointedAtType</span> <span class="p">??</span> <span class="nf">CreateErrorType</span><span class="p">(),</span> <span class="n">hasErrors</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>We can even use the template technique for type declarations - just replace <code class="language-plaintext highlighter-rouge">T</code> with whatever we get from the user:</p> <div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">private</span> <span class="k">static</span> <span class="k">readonly</span> <span class="n">SyntaxTemplate</span> <span class="n">_propertyReferenceTypeTemplate</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SyntaxTemplate</span><span class="p">(</span><span class="s">"System.IProperty&lt;T&gt;"</span><span class="p">);</span>

<span class="k">internal</span> <span class="n">Symbol</span> <span class="nf">BindNamespaceOrTypeOrAliasSymbol</span><span class="p">(</span><span class="n">ExpressionSyntax</span> <span class="n">syntax</span><span class="p">,</span> <span class="n">DiagnosticBag</span> <span class="n">diagnostics</span><span class="p">,</span> <span class="n">ConsList</span><span class="p">&lt;</span><span class="n">Symbol</span><span class="p">&gt;</span> <span class="n">basesBeingResolved</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">suppressUseSiteDiagnostics</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">syntax</span><span class="p">.</span><span class="n">Kind</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="p">...</span>

        <span class="k">case</span> <span class="n">SyntaxKind</span><span class="p">.</span><span class="n">PropertyReferenceType</span><span class="p">:</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="nf">RedirectDiagnostics</span><span class="p">(</span><span class="n">diagnostics</span><span class="p">,</span> <span class="n">syntax</span><span class="p">,</span> <span class="n">redirected</span> <span class="p">=&gt;</span> <span class="nf">BindNamespaceOrTypeOrAliasSymbol</span><span class="p">(</span>
                    <span class="n">_propertyReferenceTypeTemplate</span><span class="p">.</span><span class="nf">Replace</span><span class="p">(</span><span class="s">"T"</span><span class="p">,</span> <span class="p">((</span><span class="n">PropertyReferenceTypeSyntax</span><span class="p">)</span><span class="n">syntax</span><span class="p">).</span><span class="n">ElementType</span><span class="p">).</span><span class="n">Syntax</span><span class="p">,</span>
                    <span class="n">redirected</span><span class="p">,</span> <span class="n">basesBeingResolved</span><span class="p">,</span> <span class="n">suppressUseSiteDiagnostics</span><span class="p">));</span>
            <span class="p">}</span>
</code></pre></div></div> <p>That’s every change needed to support the feature. If you want to play with it (and even add features of your own using the <code class="language-plaintext highlighter-rouge">SyntaxTemplate</code> class), I’ve <a href="https://roslyn.codeplex.com/SourceControl/network/forks/danielearwicker/roslynoperatormethods" rel="external nofollow noopener" target="_blank">updated my fork with all these changes</a>. You will need to define the <code class="language-plaintext highlighter-rouge">System.IProperty</code> and <code class="language-plaintext highlighter-rouge">System.Property</code> types - it will work if you just paste the code.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Not yet regretting the time you've spent here?</h2> <p class="mb-2">Keep reading:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/ai3/">Poorly Structured Notes on AI Part 3</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/ai2/">Poorly Structured Notes on AI Part 2</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/ai1/">Poorly Structured Notes on AI Part 1</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/Prompt-Engineer/">How to become a prompt engineer</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/Time-reversible-events/">Time reversible events</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Daniel Earwicker. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>