<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Language Smackdown: Java vs. C# | Daniel Earwicker </title> <meta name="author" content="Daniel Earwicker"> <meta name="description" content="You are almost certainly lost on the Internet. "> <meta name="keywords" content="coding, physics"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.png?754e6b58bcf99910aed4f8d8638bd47f"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://danielearwicker.github.io/blog/2023/Java-Csharp/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Daniel</span> Earwicker </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Language Smackdown: Java vs. C#</h1> <p class="post-meta"> Created on March 07, 2023 </p> <p class="post-tags"> <a href="/blog/2023"> <i class="fa-solid fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/blog/tag/languages"> <i class="fa-solid fa-hashtag fa-sm"></i> languages</a>   <a href="/blog/tag/c"> <i class="fa-solid fa-hashtag fa-sm"></i> c#</a>   <a href="/blog/tag/java"> <i class="fa-solid fa-hashtag fa-sm"></i> java</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p>A pithy quote:</p> <blockquote> <p>There are only two kinds of languages: the ones people complain about and the ones nobody uses.</p> </blockquote> <p>Now you might say that’s exactly what the creator of C++ would say to cover his tracks. But the point is that Java and C# are languages that are 20 to 25 years old, widely used (maybe 15 million users between them), and are both cursed with toxic corporate associations. When Java first came along it was <em>cool</em>, if a programming language ever could be. But this was because the only Java code in the wild was neat little animations and things like that. As soon as it became widely used for boring line-of-business apps, it began to be thought of as the new COBOL.</p> <p>But the corporate toxicity is the clincher. Microsoft, it is generally believed, only created C# because they couldn’t find a way to take over Java without getting into further legal difficulties. Meanwhile Oracle is perhaps the only corporation that could rival Microsoft for historical unpopularity, and yet they found a way to take over Java, and happily continue creating legal difficulties for others.</p> <p>But despite all this, Java and C# are worth studying, because they started off deliberately similar, and have diverged, and then somewhat reconverged, so we can see the same ideas being twisted in different directions. Two sort-of similar languages that have evolved separately are like different universes in the multiverse, and that’s interesting.</p> <p>Also, the way these languages are judged is quite irrational. Look at C, which remains hugely popular, widely used, a terrible choice for most applications, and ultimately originates from a corporation (AT&amp;T) that wasn’t allowed to sell it as a product as they were bound by an antitrust settlement.</p> <h1 id="two-households-both-alike-in-dignity">Two households, both alike in dignity</h1> <p>Even from the very beginning there were certain key differences that had long term consequences. C# had the advantage of being able to learn from Java, such that many of the <a href="http://www.javapuzzlers.com" rel="external nofollow noopener" target="_blank">odd edge cases and pitfalls</a> that can occur in the earlier language are automatically ruled out.</p> <p>Take for example Java’s schism between primitives (<code class="language-plaintext highlighter-rouge">boolean</code>, <code class="language-plaintext highlighter-rouge">char</code>, <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">long</code>, <code class="language-plaintext highlighter-rouge">double</code>…) and everything else. Primitives fit into a little space so that’s all they ever need to be: a patch of memory intepreted as a number. Whereas everything else, and that includes things as simple as a <code class="language-plaintext highlighter-rouge">String</code> or a nice <code class="language-plaintext highlighter-rouge">ComplexNumber</code> class, is far more complicated. A <code class="language-plaintext highlighter-rouge">String</code> variable holds the address of an object, and that object has a header that takes up a bunch of space, and multiple variables may point to the same object, which implies a decision has to be taken over when it’s safe to throw away the object, so it has to be managed by GC. To be sure, all this stuff sounds worse than it is, and most of the time in most applications it doesn’t matter a bit (which is why Java has millions of users despite all this).</p> <p>But consider that <code class="language-plaintext highlighter-rouge">ComplexNumber</code>. Just to be extra unfair, let’s say that on a 64-bit platform we’re using two 32-bit <code class="language-plaintext highlighter-rouge">float</code>s (total 8 bytes), to which the Java runtime adds a standard header big enough to hold two pointers, so that is another 16 bytes. If you’re storing a lot of these objects in memory, you might care that this has tripled your memory requirement. And you’re probably holding them all in an array, or should I say “in” an array: the array doesn’t store the objects, just their addresses, which means there’s another 8 extra bytes per object. So 8 has become 32, and 75% of your memory is being used to store bureaucratic paperwork.</p> <p>But C# has your back, because you can define your own primitives with the <code class="language-plaintext highlighter-rouge">struct</code> keyword and know that they are packed tightly into memory just like individual <code class="language-plaintext highlighter-rouge">float</code>s are. There’s still a schism, because your type must be either <code class="language-plaintext highlighter-rouge">struct</code> or <code class="language-plaintext highlighter-rouge">class</code>. But the difference is somewhat papered over because at the root of the type system, “everything’s an object”. If you have a variable of type <code class="language-plaintext highlighter-rouge">object</code>, you can assign an instance of your <code class="language-plaintext highlighter-rouge">ComplexNumber</code> to it, through the miracle-kludge of automatic boxing: the language has the ability to treat a <code class="language-plaintext highlighter-rouge">struct</code> as if it were a <code class="language-plaintext highlighter-rouge">class</code>, where required (though not vice versa).</p> <p>These things are likely to gradually make their way into Java over the next few years though:</p> <ul> <li><a href="https://openjdk.java.net/jeps/401" rel="external nofollow noopener" target="_blank">JEP 401: Primitive Classes</a></li> </ul> <h1 id="episodet---generics"> <code class="language-plaintext highlighter-rouge">Episode&lt;T&gt;</code> - Generics</h1> <p>If you’re thinking of designing the next great general purpose language with static typing, please remember to include generics in the first version and save yourself a world of pain. You <em>are</em> going to add them, <a href="https://www.infoworld.com/article/3645228/go-118-arrives-with-much-anticipated-generics.html" rel="external nofollow noopener" target="_blank">even if you wait ten years</a>.</p> <p>In due course, Java (2004) and C# (2005) got them, in a near simultaneous development. And yet they ways they went about it almost couldn’t be more different. There’s a <a href="https://openjdk.java.net/projects/valhalla/design-notes/in-defense-of-erasure" rel="external nofollow noopener" target="_blank">great write-up of the Java approach here</a> but it’s notably quite a defensive account, and it has to be, because there’s a perception that, comparatively, C# “did it right”. Java aimed to make it so that a class author could add <code class="language-plaintext highlighter-rouge">&lt;T&gt;</code> to the end of the class’s name and still have the compiler produce a <code class="language-plaintext highlighter-rouge">.class</code> file that could be dynamically loaded by an application that was built before generics existed. This would allow generics to smoothly make their way into regular usage without breaking any applications.</p> <p>But it imposed some fairly extreme limitations that persist today. You cannot use a primitive as a type argument, and you cannot find out anything much about generic types at runtime. Java introduced auto-boxing for primitives along similar lines to C#, but as noted above, this means that if you need to conserve memory when dealing with large quantities of primitive values, then you can forget about generics. C# avoids that problem entirely: you can say <code class="language-plaintext highlighter-rouge">MyClass&lt;int&gt;</code> and it will be like <code class="language-plaintext highlighter-rouge">int</code> is substituted everywhere that <code class="language-plaintext highlighter-rouge">T</code> appeared in the source. For value types, it’s very reminiscent of C++ templates, but only in the good aspects.</p> <p>As Brian Goetz tells it:</p> <blockquote> <p>C# made the opposite choice — to update their VM, and invalidate their existing libraries and all the user code that dependend [sic] on it. They could do this at the time because there was comparatively little C# code in the world; Java didn’t have this option at the time.</p> </blockquote> <p>But this isn’t really accurate. The get-out of entirely ignoring backward compatibility is a straw man, available to neither language. Certainly C# wasn’t as well established as Java by 2005, but it was on a very fast upward curve, and this meant it was even less able to afford to alienate its early adopters. The result - at best - would have been a Python 2 versus 3 scenario, which clearly didn’t happen, or a fatal crisis of confidence among users, which didn’t happen either. To see why, you can do a little experiment (I actually did this):</p> <ul> <li>Set up a C# 1.0 environment (I created, with some difficulty, a VM running Windows XP Service Pack 3 and installed Visual Studio .NET 2002.)</li> <li>Write a class library with some static methods that accept/return <code class="language-plaintext highlighter-rouge">ArrayList</code> and <code class="language-plaintext highlighter-rouge">Hashtable</code> objects.</li> <li>Build it and then copy the resulting DLL to your present day environment where you have .NET 6.</li> <li>Run <code class="language-plaintext highlighter-rouge">dotnet new console</code> to create an app and make it depend on your ancient relic DLL: call the methods, print the return values etc.</li> </ul> <p>You’ll find that it loads and runs just fine. An assembly <code class="language-plaintext highlighter-rouge">.dll</code> produced by the very first version of the C# compiler is still supported <em>today</em>. It even works on Linux, or Mac OS on Apple silicon. All the non-generic collection classes that were in version 1 still exist in today’s platform. So we can see that C# certainly didn’t make the decision to invalidate their (or anyone else’s) existing libraries or break binary compatibility at all. They made it possible for generic and non-generic classes to coexist side by side.</p> <p>So what is the actual difference in Java’s approach? If you use today’s C# tools to build a class that uses generic collections and then send it back to your simulation of 2002, that old version of the runtime won’t know what to do with it. The question is, did that ever really matter?</p> <p>I’d say that Java’s erasure approach placed the past on a pedestal, at the expense of the future. Generics are forever doomed to act like they don’t exist, to avoid upsetting the code written during Java’s first decade, and to the detriment of developers (and language designers) working in the subsequent two decades and beyond. The C# reification approach works like a compromise that doesn’t materially harm either side of the equation: from the perspective of the future it looks very well designed and complete, and yet to the past it was sufficiently accommodating, if not perfectly so.</p> <p>In C# objects genuinely know what type they are at runtime, and the reflection system provides a rich, explorable network of facts about how the types were generated. In Java, the reflection system is curiously stuck in the now distant past (well, almost; confusingly there are places in the reflection system that know about generics, but they are mostly stymied by erasure).</p> <p>The irony is that after all that care taken by Java to appease the past, it eventually did have to adopt <a href="https://www.theregister.com/2019/03/07/java_developers_version_8/" rel="external nofollow noopener" target="_blank">a more aggressive attitude to upgrading itself</a>, requiring users to get accustomed to having to upgrade their package dependencies to some newer compatible combination <a href="https://carlmastrangelo.com/blog/the-impossible-java-11" rel="external nofollow noopener" target="_blank">whenever they migrated to a new major version of the platform</a>. This isn’t actually as traumatic as it sounds, even though it does often involve code changes, and is the norm in most ecosystems.</p> <p>What’s perhaps a little worse is that because the use of erasure was so well known, and could therefore be depended on in code, it became commonplace for code to assume that a type parameter was always a reference type, based on <code class="language-plaintext highlighter-rouge">Object</code>, and therefore that it would be safe to allocate an <code class="language-plaintext highlighter-rouge">Object[]</code> and use it to store elements of a parameter type. This gets in the way of attempts to enhance the JVM to support allowing primitive type arguments in an efficient way. Also methods like <code class="language-plaintext highlighter-rouge">remove(Object item)</code> often retain that pre-2004 signature even for collections of <code class="language-plaintext highlighter-rouge">&lt;T&gt;</code>, which is pretty unhelpful; while it may not cause a type error at runtime, it can conceal a logical bug.</p> <p>Again, there is work in the pipeline:</p> <ul> <li><a href="https://openjdk.java.net/jeps/8261529" rel="external nofollow noopener" target="_blank">JEP draft: Universal Generics</a></li> </ul> <p>But it’s focused purely on avoiding the performance bottleneck imposed by only supporting reference types; there’s no plan to fully reify generics. There may be no way to do that now without creating a Python 2/3 style bifurcation.</p> <h1 id="iterating-neednt-be-irritating">Iterating needn’t be irritating</h1> <p>C# 1 included a neat feature: <code class="language-plaintext highlighter-rouge">foreach</code>. The equivalent appeared in Java 5, the same release that added generics. Strictly speaking it’s only a near equivalent. An important part of the protocol for such a loop is dealing with the case where the user breaks out early:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="o">(</span><span class="kt">var</span> <span class="n">joke</span> <span class="o">:</span> <span class="n">jokeBook</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">inBadMood</span><span class="o">())</span> <span class="o">{</span>
        <span class="k">break</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div> <p>In the equivalent statements in C# (and JavaScript for that matter), when we leave the loop there is a way to notify the iterator so it can dispose of any resources it might be using. The <code class="language-plaintext highlighter-rouge">IEnumerator&lt;T&gt;</code> interface derives from <code class="language-plaintext highlighter-rouge">IDisposable</code>, which introduces the <code class="language-plaintext highlighter-rouge">Dispose</code> method.</p> <p>But this part of the iteration pattern is absent from Java. It was only added to C# in version 2, and perhaps not coincidentally this was at the same time C# gained iterator methods via <code class="language-plaintext highlighter-rouge">yield return</code>, another (truly awesome) feature that has an exact analog in JS and Python but not in Java.</p> <h1 id="java-snoozes-and-loses">Java snoozes and loses</h1> <p>There seems to have been some kind of politically-imposed stagnation that stopped Java making any significant enhancements between 2005-2011, possibly due to a sense that if generics were anything to go by, “new” means “bad”. Meanwhile during this period alone, C# gained, in addition to generics:</p> <ul> <li><code class="language-plaintext highlighter-rouge">yield return</code></li> <li>extension methods</li> <li>lambdas</li> <li> <code class="language-plaintext highlighter-rouge">var</code> (inference of local variable types)</li> <li>anonymous types</li> <li>query expressions</li> <li>expression trees</li> <li>auto properties</li> <li><code class="language-plaintext highlighter-rouge">dynamic</code></li> <li>out/in on type parameters</li> <li>optional parameters and named arguments</li> </ul> <p>This period fundamentally changed what idiomatic C# code looked like, so that it gained entirely its own style that couldn’t be replicated in Java.</p> <h1 id="the-java-renaissance">The Java renaissance?</h1> <p>In 2011 some significant new features finally snuck in to Java, the most notable being the <code class="language-plaintext highlighter-rouge">try</code>-with-resources statement, because it very closely resembled the C# 1 feature the <code class="language-plaintext highlighter-rouge">using</code>-statement. It is accompanied by an <code class="language-plaintext highlighter-rouge">AutoCloseable</code> interface, which corresponds to the <code class="language-plaintext highlighter-rouge">IDisposable</code> interface of .NET.</p> <p>This might have been an ideal time to make collection <code class="language-plaintext highlighter-rouge">for</code>-statement sniff the iterator for <code class="language-plaintext highlighter-rouge">AutoCloseable</code> so that iterators had a way to be notified in the event of an early <code class="language-plaintext highlighter-rouge">break</code> from the loop, but this didn’t happen.</p> <p>And after years of debate and delay, and against the wishes of a vocal subset of the user community, Java finally got lambdas, in its own way; again, the comparison is interesting. In C# there is the notion of a delegate, the type of something that can be called with <code class="language-plaintext highlighter-rouge">()</code>. Java resisted adding this, and instead noted that it is equivalent to an interface with one method (as long as it isn’t a generic method). Consequently a lambda could be used to implement any such interface.</p> <p>I really like this approach. Also it gives me a chance to complain about something that I think C# took in the wrong direction from the very start, and it’s too late to fix now, which will help to even up the bias in this post so far.</p> <p>I think using the function call <code class="language-plaintext highlighter-rouge">()</code> syntax directly on a type with one method should be equivalent to calling a method called <code class="language-plaintext highlighter-rouge">Invoke</code>, and that would remove the need for delegates to exist as a separate concept (this is so nearly the case; delegates do have methods, and one of them is <code class="language-plaintext highlighter-rouge">Invoke</code>.) This is an example of syntactic sugar compiling down to method calls, which is how many more recent features of C# work, but was underappreciated in the early days.</p> <p>A major difference between C# and Java lambdas is their ability to close over local variables. Both can do this, but only C# lambdas can capture a local (or parameter) that is mutable. The compiler has to do something rather strange to achieve this, moving the local variables into fields of a hidden class so they can continue their independent existence after the stack frame has vanished. Java decided against this level of concealed complexity and instead just refuses to compile a lambda that refers to a local variable whose value ever changes. Note that this cannot be defended as an example of some principled refusal to deal with mutable data, because Java will quite happily allow a lambda to read mutable fields of a object stored in a captured local.</p> <p>But as part of the same enhancement as lambdas, the tables were truly turned. Java did something it hadn’t managed for about 20 years: it introduced a new feature that would later be copied by C#. This was default interface methods, originally known as <a href="http://wiki.jvmlangsummit.com/images/7/71/2011_Goetz_Extension.pdf" rel="external nofollow noopener" target="_blank">virtual extension methods</a>, which were needed for the same purpose as C# static extension methods, but they are objectively <em>better</em>.</p> <p>A familiar problem when unit testing code that uses a package that includes extension methods is wanting to mock an interface, only to find that the method you’re calling is actually an extension on the interface, so it can’t be directly mocked. If only they’d used default interface methods! The same magic ability to make a new method appear on all existing implementations of an interface, but dispatch is properly polymorphic. But this excellent alternative wouldn’t appear in C# until version 9.0, five years later.</p> <h1 id="linq-and-streams">LINQ and streams</h1> <p>Here I’m conflating C# with the CLR, which these days is a reasonably safe thing to do. If you want to iterate through a collection you need something to represent the state of the iteration, and this needs to be an object distinct from the collection itself. In Java it’s called an <code class="language-plaintext highlighter-rouge">Iterator&lt;T&gt;</code>, while in C# it’s an <code class="language-plaintext highlighter-rouge">IEnumerator&lt;T&gt;</code>.</p> <p>From this perspective a collection is a thing from which you can obtain one of these iteration states, presumably initialised to the start of the collection. And sure enough, in Java a collection implements <code class="language-plaintext highlighter-rouge">Iterable&lt;T&gt;</code> (with its <code class="language-plaintext highlighter-rouge">iterator</code> method that returns an <code class="language-plaintext highlighter-rouge">Iterator&lt;T&gt;</code> ) and in C# it implements <code class="language-plaintext highlighter-rouge">IEnumerable&lt;T&gt;</code> (with <code class="language-plaintext highlighter-rouge">GetEnumerator</code> that returns an <code class="language-plaintext highlighter-rouge">IEnumerator&lt;T&gt;</code>.) So far, so isomorphic.</p> <p>But then the issue arises of how to provide helpful, composable operations on collections. The classic examples are <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">flatMap</code>, <code class="language-plaintext highlighter-rouge">filter</code> and <code class="language-plaintext highlighter-rouge">reduce</code>. In Java they have these exact names, where as in C# they are renamed <code class="language-plaintext highlighter-rouge">Select</code>, <code class="language-plaintext highlighter-rouge">SelectMany</code>, <code class="language-plaintext highlighter-rouge">Where</code> and <code class="language-plaintext highlighter-rouge">Aggregate</code>, by analogy with SQL (as if to put people off).</p> <p>But the real distinction is in where these operations appear. In C#, which gained them in 2007, they appear as extensions on <code class="language-plaintext highlighter-rouge">IEnumerable&lt;T&gt;</code>, that is, on collections, whereas in Java, which waited until 2014, they appear on a new object called a <code class="language-plaintext highlighter-rouge">Stream&lt;T&gt;</code> which:</p> <ul> <li>is be obtained from the collection by calling <code class="language-plaintext highlighter-rouge">stream</code> </li> <li>can only be used once</li> </ul> <p>It seems a lot like another flavour of <code class="language-plaintext highlighter-rouge">Iterable&lt;T&gt;</code>. And you might expect a corresponding <code class="language-plaintext highlighter-rouge">Streamable&lt;T&gt;</code> to be implemented by collections with a <code class="language-plaintext highlighter-rouge">stream</code> method, and <a href="https://mail.openjdk.org/pipermail/lambda-libs-spec-experts/2013-February/001287.html" rel="external nofollow noopener" target="_blank">early in the development of this feature that was the case, but it was removed</a>. Could the operations have just been provided as default interface methods on <code class="language-plaintext highlighter-rouge">Iterator&lt;T&gt;</code>? It seems so.</p> <p>In any case, this is a fundamental difference but I’m not sure what to make of it. A C# method can accept a collection in the form of an <code class="language-plaintext highlighter-rouge">IEnumerable&lt;T&gt;</code>, and can therefore make multiple passes through it. A Java method that is passed a <code class="language-plaintext highlighter-rouge">Stream</code> can only make one pass. But the multi-pass capability is a double-edged sword. In C# when reviewing code I have occasionally discovered some very easy performance wins by adding <code class="language-plaintext highlighter-rouge">ToList()</code> here and there, to materialize an <code class="language-plaintext highlighter-rouge">IEnumerable&lt;T&gt;</code> that was being expensively re-evaluated. And conversely, I’m not sure I’ve wanted that kind of behaviour deliberately. I guess low memory conditions and very large data sets could be a compelling use case for lazy re-processing of a collection that doesn’t memoize the results of the first pass, but it seems odd that it’s the default in C#.</p> <p>Verdict: hmmm.</p> <h1 id="a-pattern-emerges">A pattern emerges</h1> <p>Over the last few years the two languages seem to have been adding very similar features at quite a pace. With pattern matching, C# 7.0 (2017) led the way. In its simplest form, an <code class="language-plaintext highlighter-rouge">if</code> statement can declare a variable:</p> <div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="n">someObj</span> <span class="k">is</span> <span class="kt">string</span> <span class="n">someStr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// in this scope we know someStr is a string</span>
<span class="p">}</span>
</code></pre></div></div> <p>Likewise in Java 14 (2020), as a preview feature, you could say:</p> <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="o">(</span><span class="n">someObj</span> <span class="k">instanceof</span> <span class="nc">String</span> <span class="n">someStr</span><span class="o">)</span> <span class="o">{</span>
    <span class="c1">// in this scope we know someStr is a string</span>
<span class="o">}</span>
</code></pre></div></div> <p>But C# went much further, sooner. Similar enhancements appeared at the same time in the <code class="language-plaintext highlighter-rouge">switch</code> statement, and tuples, and a form of destructuring to go with them (positional only, therefore). As with so many of these feature additions, neither language is inventing them; there are many pre-existing languages, often with quite niche communities, that have pioneered these features for years (even several decades), and both C# and Java are cherry-picking them for integration into their own, more popular, platforms and so bringing them to a much wider audience. Sometimes they do so in a strikingly identical way, thanks to commonalities in their basic implementations, and sometimes they are forced to diverge.</p> <p>Records have appeared in both languages also. Simplistically these are class-like and lean towards succinct declaration for a “primary” constructor, and toward immutability, and the provision of automatic implementations of equality comparison and hashcodes, i.e. they are value-like (by default, anyway.) But as with lambdas and closing over mutable locals, C# goes the extra mile even though it increases the complexity of its implementation. Java records cannot inherit implementation (only interfaces). But in C#, a record can inherit another record, and this means the language has to be careful about what equality means. Also there’s the delightful <code class="language-plaintext highlighter-rouge">with</code> expression that can perform a non-mutating update, and which also strives to provide non-surprising behaviour under inheritance. The expression:</p> <div class="language-c# highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">x</span> <span class="k">with</span> <span class="p">{</span> <span class="n">FirstName</span> <span class="p">=</span> <span class="s">"Joe"</span> <span class="p">}</span>
</code></pre></div></div> <p>produces a modified clone of the runtime type of <code class="language-plaintext highlighter-rouge">x</code>, which may differ from the compile-time type, so polymorphism is properly honoured.</p> <h1 id="whats-next">What’s next?</h1> <p>Probably the most interesting recent C# feature is <a href="https://learn.microsoft.com/en-us/dotnet/csharp/whats-new/tutorials/static-virtual-interface-members" rel="external nofollow noopener" target="_blank">static virtual interface members</a>, which greatly increases the expressiveness of generic types. In mathematics when we introduce an operator closed over a set, we often introduce special elements of the set like a “zero”. Now we can write such concepts down in C#. Or thinking more practically, we can do much of what C++ traits have always been able to do.</p> <p>Your move, Java!</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Not yet regretting the time you've spent here?</h2> <p class="mb-2">Keep reading:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/ai3/">Poorly Structured Notes on AI Part 3</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/ai2/">Poorly Structured Notes on AI Part 2</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/ai1/">Poorly Structured Notes on AI Part 1</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/Prompt-Engineer/">How to become a prompt engineer</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/Time-reversible-events/">Time reversible events</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Daniel Earwicker. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>