<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> From Ember to React, Part 2: Baby, Bathwater, Routing, etc. | Daniel Earwicker </title> <meta name="author" content="Daniel Earwicker"> <meta name="description" content="You are almost certainly lost on the Internet. "> <meta name="keywords" content="coding, physics"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/assets/img/favicon.png?754e6b58bcf99910aed4f8d8638bd47f"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://danielearwicker.github.io/blog/2018/Ember-React-2/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Daniel</span> Earwicker </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">From Ember to React, Part 2: Baby, Bathwater, Routing, etc.</h1> <p class="post-meta"> Created on March 18, 2018 </p> <p class="post-tags"> <a href="/blog/2018"> <i class="fa-solid fa-calendar fa-sm"></i> 2018 </a>   ·   <a href="/blog/tag/ember"> <i class="fa-solid fa-hashtag fa-sm"></i> Ember</a>   <a href="/blog/tag/react"> <i class="fa-solid fa-hashtag fa-sm"></i> React</a>   <a href="/blog/tag/typescript"> <i class="fa-solid fa-hashtag fa-sm"></i> TypeScript</a>   <a href="/blog/tag/mobx"> <i class="fa-solid fa-hashtag fa-sm"></i> MobX</a> </p> </header> <article class="post-content"> <div id="markdown-content"> <p><em>Abstract</em>: Last time, which was too long ago, I explained why Ember is terrible and must be burnt to the ground. This time I’ll begin to explain why it’s not actually all terrible and we should run back into the burning building to rescue the good parts. This will lead us to answer the question: can React Router be used with MobX?</p> <ul> <li><a href="../../2017/Ember-React-1">From Ember to React, Part 1: Why Not Ember?</a></li> <li><em>From Ember to React, Part 2: Baby, Bathwater, Routing, etc.</em></li> </ul> <h1 id="magic">Magic</h1> <p>A lot of the good parts of Ember are replaced, but made much better, by <a href="https://github.com/mobxjs/mobx" rel="external nofollow noopener" target="_blank">MobX</a>, which is a small library that has a huge impact. I’ve introduced people to it and seen them become <em>giddy</em> at how easy things suddenly become.</p> <p>As we replace Ember with React, and we find it a much more sparse and simple offering, MobX fills an extraordinary number of gaps. A lot of the “magic” in Ember, things that update automatically and so on, is just repeated application of the core ideas of reactive programming. By applying them ourselves explicitly, they become clearer, less magical but no less powerful and helpful.</p> <h1 id="routing">Routing</h1> <p>Web apps obey the address bar, or (in fancy terms) the web app is in some sense a <em>projection</em> of the address bar. The address bar says where we are in the app. To ensure consistency, if some part of the UI serves as a doorway to get to another place, it should <em>not</em> directly update the UI. It should update the address bar, and then that should have the effect of causing the navigation to occur. This sequence of cause and effect is important because it guarantees that pasting a URL into the address bar will also work as a way to get there: external links, bookmarks and history will all work as expected.</p> <p>This is enforced by using routes and links in your app. Actual <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> elements are best, if you can stick to them, because they also afford the expected right-click-open-in-new-tab behaviour. Failing that, use <code class="language-plaintext highlighter-rouge">history.pushState</code> to set the <code class="language-plaintext highlighter-rouge">location</code> to the new address. The rest should be done by handling routes. A routing library is just a pattern for handling an event when the address bar changes.</p> <p>Ember has a pattern for doing this which (like a few other things in Ember) is driven by how your lay out your source files.</p> <p>React has nothing built-in for routing, because it doesn’t need to. It’s designed to do one thing very well, as part of an ecosystem of libraries in <code class="language-plaintext highlighter-rouge">npm</code>. Probably the most popular routing solution in React is <a href="https://reacttraining.com/react-router/" rel="external nofollow noopener" target="_blank">react-router</a>. Let’s go with it, because it’s very simple at heart: the <code class="language-plaintext highlighter-rouge">Route</code> element is really just a disguised <code class="language-plaintext highlighter-rouge">if</code> statement. React Router is well known and should be unsurprising…</p> <p>Well, there are some things about it that may come as a surprise.</p> <h2 id="query-strings">Query Strings</h2> <p>First, it completely ignores the query string portion of the URL, a.k.a. <code class="language-plaintext highlighter-rouge">location.search</code>. That is, in a URL such as <code class="language-plaintext highlighter-rouge">https://mysite/store/tshirts?size=large</code>, <code class="language-plaintext highlighter-rouge">react-router</code> is only interested in <code class="language-plaintext highlighter-rouge">/store/tshirts</code>. It pays no attention to the <code class="language-plaintext highlighter-rouge">?</code> and what comes after it. This was a change in version 4 and so you can <a href="https://github.com/ReactTraining/react-router/issues/4410" rel="external nofollow noopener" target="_blank">find a lot of people bellyaching about it here</a>.</p> <p>The bellyachers think that all parts of the URL ought to be treated the same way. The authors of React Router don’t think so. Neither did the authors of Ember. I think you could argue it several ways. Yes, <code class="language-plaintext highlighter-rouge">/store/tshirts</code> is a place, but isn’t <code class="language-plaintext highlighter-rouge">?size=large</code> essentially the “place” where we keep the large T-Shirts? Well, if it is we should call it <code class="language-plaintext highlighter-rouge">/store/tshirts/large</code>. It’s not a place, but rather a filtered view of a place. We want it to behave like a place in some ways, because we’ve mentioned it in our address bar. But we also want to clarify that it is less solid than a place, because it can be combined with <code class="language-plaintext highlighter-rouge">&amp;color=red</code> and various other criteria, in whatever order. Ultimately these distinctions are fragile choices driven by our mental model of one small part of the world. But the <code class="language-plaintext highlighter-rouge">?</code> part of the URL has a distinct purpose. It is not path-like; it’s a bag of name/value pairs separated by <code class="language-plaintext highlighter-rouge">&amp;</code>.</p> <p>In Ember, there is (of course) some built-in magic. If the user navigates to <code class="language-plaintext highlighter-rouge">/store/tshirts</code> and then adjusts their filtering options so the address becomes <code class="language-plaintext highlighter-rouge">/store/tshirts?size=large</code>, and then they navigate away to <code class="language-plaintext highlighter-rouge">/store/houseplants</code>, Ember secretly holds onto that <code class="language-plaintext highlighter-rouge">?size=large</code> somewhere. They call it <a href="https://guides.emberjs.com/v2.13.0/routing/query-params/#toc_sticky-query-param-values" rel="external nofollow noopener" target="_blank">Sticky Query Parameter Values</a>. It means that links going back to <code class="language-plaintext highlighter-rouge">/store/tshirts</code> will automatically go to <code class="language-plaintext highlighter-rouge">/store/tshirts?size=large</code>. This is opinionated, but it’s a reasonable opinion: query params are filter settings specific to a path, and when we leave a room it shouldn’t magically tidy itself back to a starting state. It should remain as we left it, so we can come back to it and find it the same. So this is really unmagic.</p> <p>I will return to this in part three, because first we have to deal with a more basic issue.</p> <h2 id="update-blocking">Update Blocking</h2> <p>This is the guilty secret of React Router, but if you read far enough <a href="https://github.com/ReactTraining/react-router/blob/master/packages/react-router/docs/guides/blocked-updates.md" rel="external nofollow noopener" target="_blank">you can find a full confession</a>. Unfortunately the library’s whole approach depends on an assumption that isn’t reliable, and it would be a deal breaker if we couldn’t fix it. But fortunately we can.</p> <p>To clarify why this is important, what they call “update blocking components” really should be all components. React performs much better if components only re-render when they need to. This is one of the excellent things about <code class="language-plaintext highlighter-rouge">mobx-react</code>. Wrapping your components with <code class="language-plaintext highlighter-rouge">@observer</code> automatically means that they only update when there is a change of the values of props or observable data. This is not the default behaviour of React components (though <a href="https://reactjs.org/docs/react-api.html#reactpurecomponent" rel="external nofollow noopener" target="_blank">PureComponent</a> does something similar). React Router is broken by this; any conditional rendering using the <code class="language-plaintext highlighter-rouge">Route</code> component can only be re-evaluated if a render takes place. That means the enclosing component has to re-render. And why should any component re-render just because the address bar has changed?</p> <p>That question is the clue to the answer: the current location should be an observable. If it changes then anything dependent on it should change; so in turn the <code class="language-plaintext highlighter-rouge">Route</code> component should be an <code class="language-plaintext highlighter-rouge">@observer</code>. The address bar would be like a two-way bound text field for an observable <code class="language-plaintext highlighter-rouge">location.href</code>. Then everything would be fine. If only MobX was built into browsers, eh?</p> <h2 id="routing-backwards">Routing Backwards</h2> <p>The creator of MobX wrote <a href="https://hackernoon.com/how-to-decouple-state-and-ui-a-k-a-you-dont-need-componentwillmount-cc90b787aa37" rel="external nofollow noopener" target="_blank">a nice post on this subject</a>. He rolls a custom routing solution with three parts:</p> <ol> <li>A view-model of observable properties that describe the current state, including <code class="language-plaintext highlighter-rouge">currentView</code> which corresponds to the path of the route.</li> <li>An off-the-shelf non-React specific router library, <a href="https://github.com/flatiron/director" rel="external nofollow noopener" target="_blank">director</a>, which describes how to map from locations to actions that update the view-model.</li> <li>A computed <code class="language-plaintext highlighter-rouge">currentPath</code> property that defines what the address bar should contain right now, derived from the view-model.</li> </ol> <p>So the mapping between view-model and address bar has to be described twice, once for each direction. Here’s mapping path changes to update actions:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">router</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Router</span><span class="p">({</span>
    <span class="dl">"</span><span class="s2">/document/:documentId</span><span class="dl">"</span><span class="p">:</span> <span class="p">(</span><span class="nx">id</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">store</span><span class="p">.</span><span class="nf">showDocument</span><span class="p">(</span><span class="nx">id</span><span class="p">),</span>
    <span class="dl">"</span><span class="s2">/document/</span><span class="dl">"</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="nx">store</span><span class="p">.</span><span class="nf">showOverview</span><span class="p">(),</span>
<span class="p">});</span>
</code></pre></div></div> <p>And here’s the reverse, computing <code class="language-plaintext highlighter-rouge">currentPath</code> from the view-model (which is observed by an <code class="language-plaintext highlighter-rouge">autorun</code> that copies the value into the address bar if it doesn’t match what’s already there):</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">@</span><span class="nd">computed</span> <span class="kd">get</span> <span class="nf">currentPath</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">switch</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">currentView</span><span class="p">.</span><span class="nx">name</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="dl">"</span><span class="s2">overview</span><span class="dl">"</span><span class="p">:</span> <span class="k">return</span> <span class="dl">"</span><span class="s2">/document/</span><span class="dl">"</span>
        <span class="k">case</span> <span class="dl">"</span><span class="s2">document</span><span class="dl">"</span><span class="p">:</span> <span class="k">return</span> <span class="s2">`/document/</span><span class="p">${</span><span class="k">this</span><span class="p">.</span><span class="nx">currentView</span><span class="p">.</span><span class="nx">documentId</span><span class="p">}</span><span class="s2">`</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>On the plus side, this means that rather than following the rule that the app navigates by changing the address, it can do so by changing the view-model. This moves you out of dealing with URL syntax and into a high-level vocabulary of actions and state, which can be statically typed. Changing the view model will automatically have the side-effect of updating the address bar.</p> <p>But on the other hand, the majority of navigations will (should?) be user-driven, and will be triggered by links in the rendered UI. These should as much as possible be real <code class="language-plaintext highlighter-rouge">&lt;a&gt;</code> links, so the browser’s standard behaviour can be exhibited. Those links need address strings to link to. So that’s a third place where we need to encode the relationship between view-model and address strings. All these must be kept consistent.</p> <p>If we take this approach, we’d discard the unidirectional principle: that the web app’s visible location is a projection of the state of the address bar. We could unintentionally introduce a way for the app to update the address bar that would not have the same effect if the address was pasted into a new browser window. The discipline of making the address bar be in the “driving seat” forces us to ensure consistency, by making it necessary for us to encode everything about the new desired state into the address string.</p> <p>We can restore the primacy of the address bar. Instead of using an <code class="language-plaintext highlighter-rouge">autorun</code> to copy a computed address to the address bar, we can do the opposite: maintain an observable value of the current location and copy from the address bar into that observable any time the address bar is changed:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">locationStore</span> <span class="o">=</span> <span class="nx">observable</span><span class="p">.</span><span class="nf">box</span><span class="p">(</span><span class="nx">history</span><span class="p">.</span><span class="nx">location</span><span class="p">);</span>

<span class="nx">history</span><span class="p">.</span><span class="nf">listen</span><span class="p">((</span><span class="nx">location</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">locationStore</span><span class="p">.</span><span class="nf">set</span><span class="p">(</span><span class="nx">location</span><span class="p">));</span>
</code></pre></div></div> <p>(In strict mode, a.k.a. <code class="language-plaintext highlighter-rouge">enforceActions</code>, you’d need a <code class="language-plaintext highlighter-rouge">runInAction</code> in there). Now we could write computed properties that derive a high-level description of the current state from the current location. The only time we go the other way is when we generate address strings to go in links.</p> <p>And now we can also rescue React Router. It’s really simple:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">OptionalLocation</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">location</span><span class="p">?:</span> <span class="nx">H</span><span class="p">.</span><span class="nx">Location</span> <span class="p">};</span>

<span class="c1">// HOC that injects the observed location as a prop</span>
<span class="kd">function</span> <span class="nf">locationObserver</span><span class="o">&lt;</span><span class="nx">P</span> <span class="kd">extends</span> <span class="nx">OptionalLocation</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="nx">C</span><span class="p">:</span> <span class="nx">React</span><span class="p">.</span><span class="nx">ComponentClass</span><span class="o">&lt;</span><span class="nx">P</span><span class="o">&gt;</span>
<span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nf">observer</span><span class="p">((</span><span class="nx">props</span><span class="p">:</span> <span class="nx">P</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">(</span>
        <span class="o">&lt;</span><span class="nx">C</span> <span class="p">{...</span><span class="nx">props</span><span class="p">}</span> <span class="nx">location</span><span class="o">=</span><span class="p">{</span><span class="nx">locationStore</span><span class="p">.</span><span class="nf">get</span><span class="p">()}</span> <span class="sr">/</span><span class="err">&gt;
</span>    <span class="p">));</span>
<span class="p">}</span>

<span class="c1">// Wrap the standard RR components so they properly observe the location</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">Route</span> <span class="o">=</span> <span class="nx">locationObserver</span><span class="o">&lt;</span><span class="nx">RouteProps</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">Route_</span><span class="p">);</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">Switch</span> <span class="o">=</span> <span class="nx">locationObserver</span><span class="o">&lt;</span><span class="nx">SwitchProps</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">Switch_</span><span class="p">);</span>
<span class="k">export</span> <span class="kd">const</span> <span class="nx">NavLink</span> <span class="o">=</span> <span class="nx">locationObserver</span><span class="o">&lt;</span><span class="nx">NavLinkProps</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">NavLink_</span><span class="p">);</span>
</code></pre></div></div> <p>Remember how I said <code class="language-plaintext highlighter-rouge">Route</code> should be an observer? Well, now it is. We just use the wrapped versions of the <code class="language-plaintext highlighter-rouge">Route</code>, <code class="language-plaintext highlighter-rouge">Switch</code> and <code class="language-plaintext highlighter-rouge">NavLink</code> components. They behave exactly like the originals, passing through the same properties, except that the <code class="language-plaintext highlighter-rouge">location</code> is pulled from our global <code class="language-plaintext highlighter-rouge">locationStore</code> and passed in as a prop. So any rendering decisions based on the location will be re-evaluated automatically when the location changes. Any <code class="language-plaintext highlighter-rouge">Route</code>s and <code class="language-plaintext highlighter-rouge">NavLink</code>s scattered around the page will magically (and minimally) update themselves whenever necessary. The update blocking problem is no longer an issue.</p> <p>Note that we only have to wrap those components that accept a <code class="language-plaintext highlighter-rouge">location</code> property, and hence depend on the location. For example, <code class="language-plaintext highlighter-rouge">NavLink</code> does this so it can add an <code class="language-plaintext highlighter-rouge">active</code> class to links if they match the current location, just like the corresponding Ember feature. When I first looked at this last year, <a href="https://github.com/ReactTraining/react-router/issues/4910" rel="external nofollow noopener" target="_blank">someone else had fortunately just come the same way</a>, though as you can see I did have to update the type definition.</p> <p>One of the points made in Michel’s post was how the React Router approach makes us use <code class="language-plaintext highlighter-rouge">componentWillMount</code> to detect route changes and use them to update our view model. As Michel puts it:</p> <blockquote> <p>That doesn’t look like our UI is a function of our state. It looks more like our state is initially function of our components.</p> </blockquote> <p>I don’t think that’s necessarily true. Our state <em>includes</em> the address bar. How we interpret the address bar is a presentational problem. So the mapping from address string to view-model updates is encoded in our components. This doesn’t seem wrong to me; components are for declaring presentation, and the address string is an externally exposed part of the UI in all webapps. And as we’ve seen, due to the need to include links in the UI, components are naturally the place where we’ll create mappings in the opposite direction whenever we build an address string for a link.</p> <p>All this means is that we’ve chosen to put all the stuff to do with encoding view-model state as address strings into the components. This can look messy or tidy depending on how we do it.</p> <p>To explicitly follow the pattern, we write something like an <code class="language-plaintext highlighter-rouge">updateState</code> method that accepts props, and we add this bit of boilerplate:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">componentDidMount</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nf">updateState</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">);</span>
<span class="p">}</span>

<span class="nf">componentWillReceiveProps</span><span class="p">(</span><span class="nx">nextProps</span><span class="p">:</span> <span class="nx">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">this</span><span class="p">.</span><span class="nf">updateState</span><span class="p">(</span><span class="nx">nextProps</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <p>This is messy, but it’s just because the React lifecycle gives us two entry points by which props can arrive, in slightly different ways, because it’s a low-level API. Of course, we can eliminate that boilerplate with an HOC:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kd">function</span> <span class="nf">observerOfProps</span><span class="o">&lt;</span><span class="nx">Props</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="nx">component</span><span class="p">:</span> <span class="p">(</span><span class="nx">props</span><span class="p">:</span> <span class="nx">Props</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="nx">JSX</span><span class="p">.</span><span class="nx">Element</span><span class="p">,</span>
    <span class="nx">onProps</span><span class="p">:</span> <span class="p">(</span><span class="nx">props</span><span class="p">:</span> <span class="nb">Readonly</span><span class="o">&lt;</span><span class="nx">Props</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="k">void</span>
<span class="p">):</span> <span class="nx">React</span><span class="p">.</span><span class="nx">ComponentClass</span><span class="o">&lt;</span><span class="nx">Props</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">Observer</span> <span class="o">=</span> <span class="nf">observer</span><span class="p">(</span><span class="nx">component</span><span class="p">);</span>

    <span class="kd">class</span> <span class="nc">WithProps</span> <span class="kd">extends</span> <span class="nc">React</span><span class="p">.</span><span class="nx">Component</span><span class="o">&lt;</span><span class="nx">Props</span><span class="o">&gt;</span> <span class="p">{</span>
        <span class="nf">componentDidMount</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">onProps</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nf">componentWillReceiveProps</span><span class="p">(</span><span class="na">props</span><span class="p">:</span> <span class="nb">Readonly</span><span class="o">&lt;</span><span class="nx">Props</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
            <span class="nf">onProps</span><span class="p">(</span><span class="nx">props</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="nf">render</span><span class="p">():</span> <span class="nx">JSX</span><span class="p">.</span><span class="nx">Element</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">&lt;</span><span class="nx">Observer</span> <span class="p">{...</span><span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">}</span> <span class="sr">/&gt;</span><span class="err">;
</span>        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="nx">WithProps</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <p>This can be used instead of <code class="language-plaintext highlighter-rouge">observer</code> as a wrapper around stateless components, accepting a second function that is called whenever props are applied, so the view-model can be updated:</p> <div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">DocumentEditor</span> <span class="o">=</span> <span class="nf">observerOfProps</span><span class="p">(</span>
    <span class="nx">renderDocumentEditor</span><span class="p">,</span>
    <span class="p">({</span> <span class="nx">viewModel</span><span class="p">,</span> <span class="nx">docId</span> <span class="p">})</span> <span class="o">=&gt;</span> <span class="nx">viewModel</span><span class="p">.</span><span class="nf">loadDocument</span><span class="p">(</span><span class="nx">docId</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div></div> <p>This, combined with the above <code class="language-plaintext highlighter-rouge">observer</code>-powered versions of <code class="language-plaintext highlighter-rouge">Route</code>, etc., gives us a neat way of combining MobX with React Router, concentrating all handling of address strings in the presentation layer, and obeying the unidirectional pattern, so that our app’s apparent location is a projection of the string in the address bar.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Not yet regretting the time you've spent here?</h2> <p class="mb-2">Keep reading:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/ai3/">Poorly Structured Notes on AI Part 3</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/ai2/">Poorly Structured Notes on AI Part 2</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2025/ai1/">Poorly Structured Notes on AI Part 1</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/Prompt-Engineer/">How to become a prompt engineer</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2023/Time-reversible-events/">Time reversible events</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Daniel Earwicker. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> </body> </html>